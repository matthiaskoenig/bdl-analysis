# create a vector of treatment factors that corresponds to each element of r in step 3 with the gl function.
tm <- gl(k, 1, n*k, factor(f))   # matching treatments
# apply the function aov to a formula that describes the response r by the treatment factor tm.
# fit an analysis of variance model
av <- aov(r ~ tm)
# print out the ANOVA table with the summary function.
summary(av)
# print the corresponding p-value
p.value <- summary(av)[[1]][["Pr(>F)"]][[1]]
df.anova <- all_factor_anova()
df.anova$sig <- sapply(df.anova$p.value, significant_code)  # add significant codes
df.anova$p.holm <- p.adjust(df.anova$p.value, method ="holm" , n = length(df.anova$p.value))
df.anova$sig.holm <- sapply(df.anova$p.holm, significant_code)
# order the results py the adjusted p-values
df.anova.ordered <- df.anova[with(df.anova, order(p.holm)), ]
df.anova.ordered
# save the results
write.table(df.anova.ordered, file=file.path(resultsPath, 'BDLanova.csv'), sep="\t", quote=FALSE)
BDLanova <- df.anova
save(df.anova, file=file.path(resultsPath, "BDLanova.Rdata"))
p.accept = 0.05  # acceptance level
idx.accept = (df.anova$p.holm < p.accept)  # accepted subset
# accepted
table(df.anova$p.holm<p.accept)  # 64 rejected / 90 accepted (adjusted)
table(df.anova$p.value<p.accept) # 19 rejected / 135 accepted (unadjusted)
# subset of filtered data
BDLdata.fil <- BDLdata[, idx.accept]
BDLmean.fil <- BDLdata[, idx.accept]
library('ALL')
# plot of the data subset which is used for the correlation analysis
col2 <- colorRampPalette(c("#67001F", "#B2182B", "#D6604D", "#F4A582", "#FDDBC7",
"#FFFFFF", "#D1E5F0", "#92C5DE", "#4393C3", "#2166AC", "#053061"))
heatmap.2(t(as.matrix(BDLdata.fil)), col=col2(100), scale="row", Rowv=FALSE, Colv=FALSE,
key=TRUE, trace="none", cexRow=0.5, keysize=0.8)
png(filename=file.path(resultsPath, "BDLdata.fil.png"), width=1600, height=1600, res=200)
heatmap.2(t(as.matrix(BDLdata.fil)), col=col2(100), scale="row", Rowv=NULL, Colv=NULL,
key=TRUE, trace="none", cexRow=0.5, keysize=0.8)
dev.off()
# correlation matrix
require(corrplot)
cor.pearson <- cor(BDLdata.fil, method="pearson", use="pairwise.complete.obs")
cor.spearman <- cor(BDLdata.fil, method="spearman", use="pairwise.complete.obs")
# Helper function for creating correlation plot and saving to results folder.
f_corrplot <- function(name, data, order, folder="../results",
width=1600, height=1600, res=200){
# TODO: create the plot using the heatmap.2 with color based on histopathology
fname <- sprintf("%s_%s.png", name, order)
col2 <- HeatmapColors()
if (!is.null(folder)){
png(filename=file.path(folder, "correlation", fname), width=width, height=height, res=res)
}
corrplot(data, order=order, hclust.method="complete", method="color", type="full",
tl.cex=0.3, tl.col="black", col=col2(10))
if (!is.null(folder)){
invisible(dev.off())
}
}
# Spearman
f_corrplot("cor.spearman", data=cor.spearman, order="original", folder=resultsPath)
f_corrplot("cor.spearman", data=cor.spearman, order="hclust", folder=resultsPath)
# Pearson
f_corrplot("cor.pearson", data=cor.pearson, order="original", folder=resultsPath)
f_corrplot("cor.pearson", data=cor.pearson, order="hclust", folder=resultsPath)
# Spearman correlation with hierarchical clustering
f_corrplot("cor.spearman", data=cor.spearman, order="hclust", folder=NULL)
# Pearson correlation with hierarchical clustering
f_corrplot("cor.pearson", data=cor.pearson, order="hclust", folder=NULL)
# calculate ys1, yr1 on mean data, i.e. correlation part (S*), slope part (A) and min/max part (M) are all calculated on the mean data of all repeats.
# w <- list(w1=0.5, w2=0.25, w3=0.25)
w <- list(w1=0.5, w2=0.3, w3=0.2)
# calculate all the matrices on the filtered data set (all ys, yr correlation components are calculated on the mean data)
ysr.res <- ysr.matrices(BDLmean.fil, BDLmean.time, use="pairwise.complete.obs")
# Pearson & spearman correlation on full dataset as replacement for the
# mean Pearson/Spearman in ys and yr
cor.S_star <- ( cor(BDLdata.fil, method="spearman", use="pairwise.complete.obs") + 1 )/2
cor.R_star <- ( cor(BDLdata.fil, method="pearson", use="pairwise.complete.obs") + 1 )/2
# Calculate the ys(1,2,3) and yr(1,2,3) with single time point correlation for
# Spearman, respectively Pearson (instead of mean)
# Takes the individual correlation, slope and min/max components for the respective
# score parts and weights with the provided weighting factors (w1,w2,w3)
cor.ys1.raw <- w$w1*cor.S_star + w$w2*ysr.res$A       + w$w3*ysr.res$M
cor.ys2.raw <- w$w1*cor.S_star + w$w2*ysr.res$A_star  + w$w3*ysr.res$M_star
cor.yr1.raw <- w$w1*cor.R_star + w$w2*ysr.res$A       + w$w3*ysr.res$M
cor.yr2.raw <- w$w1*cor.R_star + w$w2*ysr.res$A_star  + w$w3*ysr.res$M_star
# extended
cor.ys3.raw <- w$w1*cor.S_star + w$w2*ysr.res$A_star2 + w$w3*ysr.res$M_star
cor.yr3.raw <- w$w1*cor.R_star + w$w2*ysr.res$A_star2 + w$w3*ysr.res$M_star
# scaling of correlation coefficient in interval [-1,1]
cor.ys1 <- 2*(cor.ys1.raw-0.5)
cor.ys2 <- 2*(cor.ys2.raw-0.5)
cor.ys3 <- 2*(cor.ys3.raw-0.5)
cor.yr1 <- 2*(cor.yr1.raw-0.5)
cor.yr2 <- 2*(cor.yr2.raw-0.5)
cor.yr3 <- 2*(cor.yr3.raw-0.5)
# plot subset for further analysis
f_corrplot("cor.ys3", data=cor.ys2, order="hclust", folder=NULL)
# and create all files on disk
f_corrplot("cor.ys1", data=cor.ys1, order="hclust", folder=resultsPath)
f_corrplot("cor.ys2", data=cor.ys2, order="hclust", folder=resultsPath)
f_corrplot("cor.ys3", data=cor.ys3, order="hclust", folder=resultsPath)
f_corrplot("cor.yr1", data=cor.yr1, order="hclust", folder=resultsPath)
f_corrplot("cor.yr2", data=cor.yr2, order="hclust", folder=resultsPath)
f_corrplot("cor.yr3", data=cor.yr3, order="hclust", folder=resultsPath)
# extreme example where the difference between pearson and spearman matters
# plot_cor_pair("Nos2", "Cxcl15")
# plot_cor_pair("albumin", "Cyp2b10")
# Plot the clusters
require('matrixStats')
# mean plots for clusters
f_normalize_centering <- function(a){
a.norm <- (a - mean(a))/(max(a, na.rm=TRUE) - min(a, na.rm=TRUE))
return(a.norm)
}
# plot of mean clusters
plot_clusters <- function(method, folder=NULL){
# create the figure
if (!is.null(folder)){
fname <- sprintf("%s_cluster_overview.png", method)
path <- file.path(folder, 'cluster', fname)
print(path)
png(filename=path, width=1600, height=1600, res=200)
}
par(mfrow=c(ceiling(sqrt(Ngroups)),ceiling(sqrt(Ngroups))))
# par(mfrow=c(2,3))
steps <- 1:8 # time points
for (k in 1:Ngroups){
g <- groups.hc.order[groups.hc.order==k]
N <- ceiling(sqrt(length(g)))
dgroup <- BDLmean[names(g)]
# centralize and normalize columns, i.e. the individual factors for comparison
dgroup.norm <- apply(dgroup, 2, f_normalize_centering)
# mean and sd for timepoints
g.mean <- rowMeans(dgroup.norm)
g.sd <- rowSds(dgroup.norm)   # apply(dgroup.norm, 2, sd)
# plot sd range
plot(1, type="n", xlab="", ylab="", xlim=c(1, 8), ylim=c(-1, 1), main=sprintf("%s : Cluster %s", method, k))
polygon(c(steps, rev(steps)), c(g.mean+g.sd, rev(g.mean-g.sd)),
col = rgb(0.5,0.5,0.5,0.5), border = NA)
# individual data
for (name in names(g)){
points(steps, dgroup.norm[, name], pch=16, col="black")
lines(steps, dgroup.norm[, name], col=rgb(0.5,0.5,0.5, 0.8), lwd=1)
}
# mean over factors in cluster
lines(steps, g.mean, col="blue", lwd=2)
}
par(mfrow=c(1,1))
if (!is.null(folder)){
invisible(dev.off())
}
}
# Plot individual time courses in cluster
plot_clusters_items <- function(folder=NULL){
for (k in 1:Ngroups){
if (!is.null(folder)){
fname <- sprintf("%s_cluster_%s.png", method, k)
path <- file.path(folder, 'cluster', fname)
png(filename=path, width=3000, height=3000, res=200)
}
g <- groups.hc.order[groups.hc.order==k]
N <- ceiling(sqrt(length(g)))
par(mfrow=c(N,N))
for (name in names(g)){
plot_single(name_A=name)
}
par(mfrow=c(1,1))
if (!is.null(folder)){
invisible(dev.off())
}
}
}
correlation_matrix_for_method <- function(method){
if (identical(method, "ys1")){
cor.cluster <- cor.ys1
}else if (identical(method, "ys2")){
cor.cluster <- cor.ys2
}else if (identical(method, "ys3")){
cor.cluster <- cor.ys3
}else if (identical(method, "yr1")){
cor.cluster <- cor.yr1
}else if (identical(method, "yr2")){
cor.cluster <- cor.yr2
}else if (identical(method, "yr3")){
cor.cluster <- cor.yr3
}else if (identical(method, "pearson")){
cor.cluster <- cor.pearson
}else if (identical(method, "spearman")){
cor.cluster <- cor.spearman
}
return(cor.cluster)
}
# apply hirarchical clustering based on selected correlation measure
cluster_methods <- c("pearson", "spearman", "ys1", "ys2", "ys3", "yr1", "yr2", "yr3")
Ngroups <-  6
for (method in cluster_methods){
print(method)
cor.cluster <- correlation_matrix_for_method(method)
# perform hierarchical clustering and cut into Ngroups clusters.
hc <- hclust(dist(cor.cluster))
groups <- cutree(hc, k=Ngroups)
groups.hc.order <- groups[hc$order]

# plot cluster overview
plot_clusters(method=method, folder=NULL)
plot_clusters(method=method, folder=resultsPath)
# plot individual clusters
plot_clusters_items(folder=resultsPath)
}
method
for (method in cluster_methods){
print(method)
}
for (method in cluster_methods){
print(method)
cor.cluster <- correlation_matrix_for_method(method)
}
for (method in cluster_methods){
print(method)
cor.cluster <- correlation_matrix_for_method(method)
# perform hierarchical clustering and cut into Ngroups clusters.
hc <- hclust(dist(cor.cluster))
groups <- cutree(hc, k=Ngroups)
groups.hc.order <- groups[hc$order]
}
for (method in cluster_methods){
print(method)
cor.cluster <- correlation_matrix_for_method(method)
# perform hierarchical clustering and cut into Ngroups clusters.
hc <- hclust(dist(cor.cluster))
groups <- cutree(hc, k=Ngroups)
groups.hc.order <- groups[hc$order]

# plot cluster overview
plot_clusters(method=method, folder=NULL)
plot_clusters(method=method, folder=resultsPath)
}
cluster_methods <- c("pearson", "spearman", "ys1", "ys2", "ys3", "yr1", "yr2", "yr3")
Ngroups <-  6
for (method in cluster_methods){
print(method)
cor.cluster <- correlation_matrix_for_method(method)
# perform hierarchical clustering and cut into Ngroups clusters.
hc <- hclust(dist(cor.cluster))
groups <- cutree(hc, k=Ngroups)
groups.hc.order <- groups[hc$order]

# plot cluster overview
plot_clusters(method=method, folder=NULL)
}
plot_clusters(method=method, folder=NULL)
for (method in cluster_methods){
print(method)
cor.cluster <- correlation_matrix_for_method(method)
# perform hierarchical clustering and cut into Ngroups clusters.
hc <- hclust(dist(cor.cluster))
groups <- cutree(hc, k=Ngroups)
groups.hc.order <- groups[hc$order]

# plot cluster overview
plot_clusters(method=method, folder=NULL)
}
Ngroups
plot_clusters(method=method, folder=NULL)
plot_clusters(method=method, folder=resultsPath)
for (method in cluster_methods){
print(method)
cor.cluster <- correlation_matrix_for_method(method)
# perform hierarchical clustering and cut into Ngroups clusters.
hc <- hclust(dist(cor.cluster))
groups <- cutree(hc, k=Ngroups)
groups.hc.order <- groups[hc$order]

# plot cluster overview
plot_clusters(method=method, folder=NULL)
}
for (method in cluster_methods){
print(method)
cor.cluster <- correlation_matrix_for_method(method)
# perform hierarchical clustering and cut into Ngroups clusters.
hc <- hclust(dist(cor.cluster))
groups <- cutree(hc, k=Ngroups)
groups.hc.order <- groups[hc$order]

# plot cluster overview
plot_clusters(method=method, folder=NULL)
}
for (method in cluster_methods){
print(method)
cor.cluster <- correlation_matrix_for_method(method)
# perform hierarchical clustering and cut into Ngroups clusters.
hc <- hclust(dist(cor.cluster))
groups <- cutree(hc, k=Ngroups)
groups.hc.order <- groups[hc$order]

# plot cluster overview
plot_clusters(method=method, folder=NULL)
}
print(method)
cor.cluster <- correlation_matrix_for_method(method)
hc <- hclust(dist(cor.cluster))
groups <- cutree(hc, k=Ngroups)
groups.hc.order <- groups[hc$order]
plot_clusters(method=method, folder=NULL)
for (method in cluster_methods){
print(method)
cor.cluster <- correlation_matrix_for_method(method)
# perform hierarchical clustering and cut into Ngroups clusters.
hc <- hclust(dist(cor.cluster))
groups <- cutree(hc, k=Ngroups)
groups.hc.order <- groups[hc$order]
# plot cluster overview
plot_clusters(method=method, folder=NULL)
}
for (method in cluster_methods){
print(method)
cor.cluster <- correlation_matrix_for_method(method)
# perform hierarchical clustering and cut into Ngroups clusters.
hc <- hclust(dist(cor.cluster))
groups <- cutree(hc, k=Ngroups)
groups.hc.order <- groups[hc$order]
# plot cluster overview
plot_clusters(method=method, folder=NULL)
plot_clusters(method=method, folder=resultsPath)
# plot individual clusters
plot_clusters_items(folder=resultsPath)
}
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
# Plot the clusters
require('matrixStats')
# mean plots for clusters
f_normalize_centering <- function(a){
a.norm <- (a - mean(a))/(max(a, na.rm=TRUE) - min(a, na.rm=TRUE))
return(a.norm)
}
# plot of mean clusters
plot_clusters <- function(method, folder=NULL){
# create the figure
if (!is.null(folder)){
fname <- sprintf("%s_cluster_overview.png", method)
path <- file.path(folder, 'cluster', fname)
print(path)
png(filename=path, width=1600, height=1600, res=200)
}
par(mfrow=c(ceiling(sqrt(Ngroups)),ceiling(sqrt(Ngroups))))
# par(mfrow=c(2,3))
steps <- 1:8 # time points
for (k in 1:Ngroups){
g <- groups.hc.order[groups.hc.order==k]
N <- ceiling(sqrt(length(g)))
dgroup <- BDLmean[names(g)]
# centralize and normalize columns, i.e. the individual factors for comparison
dgroup.norm <- apply(dgroup, 2, f_normalize_centering)
# mean and sd for timepoints
g.mean <- rowMeans(dgroup.norm)
g.sd <- rowSds(dgroup.norm)   # apply(dgroup.norm, 2, sd)
# plot sd range
plot(1, type="n", xlab="", ylab="", xlim=c(1, 8), ylim=c(-1, 1), main=sprintf("%s : Cluster %s", method, k))
polygon(c(steps, rev(steps)), c(g.mean+g.sd, rev(g.mean-g.sd)),
col = rgb(0.5,0.5,0.5,0.5), border = NA)
# individual data
for (name in names(g)){
points(steps, dgroup.norm[, name], pch=16, col="black")
lines(steps, dgroup.norm[, name], col=rgb(0.5,0.5,0.5, 0.8), lwd=1)
}
# mean over factors in cluster
lines(steps, g.mean, col="blue", lwd=2)
}
par(mfrow=c(1,1))
if (!is.null(folder)){
invisible(dev.off())
}
}
# Plot individual time courses in cluster
plot_clusters_items <- function(folder=NULL){
for (k in 1:Ngroups){
if (!is.null(folder)){
fname <- sprintf("%s_cluster_%s.png", method, k)
path <- file.path(folder, 'cluster', fname)
png(filename=path, width=3000, height=3000, res=200)
}
g <- groups.hc.order[groups.hc.order==k]
N <- ceiling(sqrt(length(g)))
par(mfrow=c(N,N))
for (name in names(g)){
plot_single(name_A=name)
}
par(mfrow=c(1,1))
if (!is.null(folder)){
invisible(dev.off())
}
}
}
correlation_matrix_for_method <- function(method){
if (identical(method, "ys1")){
cor.cluster <- cor.ys1
}else if (identical(method, "ys2")){
cor.cluster <- cor.ys2
}else if (identical(method, "ys3")){
cor.cluster <- cor.ys3
}else if (identical(method, "yr1")){
cor.cluster <- cor.yr1
}else if (identical(method, "yr2")){
cor.cluster <- cor.yr2
}else if (identical(method, "yr3")){
cor.cluster <- cor.yr3
}else if (identical(method, "pearson")){
cor.cluster <- cor.pearson
}else if (identical(method, "spearman")){
cor.cluster <- cor.spearman
}
return(cor.cluster)
}
# apply hirarchical clustering based on selected correlation measure
cluster_methods <- c("pearson", "spearman", "ys1", "ys2", "ys3", "yr1", "yr2", "yr3")
Ngroups <-  7
for (method in cluster_methods){
print(method)
cor.cluster <- correlation_matrix_for_method(method)
# perform hierarchical clustering and cut into Ngroups clusters.
hc <- hclust(dist(cor.cluster))
groups <- cutree(hc, k=Ngroups)
groups.hc.order <- groups[hc$order]
# plot cluster overview
plot_clusters(method=method, folder=NULL)
plot_clusters(method=method, folder=resultsPath)
# plot individual clusters
plot_clusters_items(folder=resultsPath)
}
library("gplots")
library("RColorBrewer")
method <- 'ys3'
cor.cluster <- correlation_matrix_for_method(method)
col2 <- HeatmapColors()
hc <- hclust(dist(cor.cluster))
# get cluster IDs for the groups
groups <- cutree(hc, k=Ngroups)
# define colors for the Ngroups clusters
# display.brewer.all()
colorset <- brewer.pal(Ngroups, "Set1")
color.map <- function(cluster_id) {return(colorset[cluster_id])}
clusterColors <- unlist(lapply(groups, color.map))
heatmap.2(cor.cluster, col=col2(100), scale="none",
key=TRUE, symkey=FALSE, trace="none", cexRow=0.5, cexCol=0.5,
main=method,
density.info="none", dendrogram="column", Rowv=as.dendrogram(hc), Colv=as.dendrogram(hc), keysize=0.8,
ColSideColors=clusterColors, revC=TRUE)
?heatmap.2
dtmp <- BDLdata.fil
# create better row names
rownames(dtmp) <- paste(rownames(BDLsamples), BDLsamples$time_fac, sep=" ")
# create vectors for the horizontal and vertical lines
v_lines <- ((1:8)*5+0.5)
f_types <- c("Antibodies", "Histology", "Biochemistry", "GE_Fibrosis", "GE_Cytokines", "GE_ADME")
# define colors for type of experimentell data, i.e. factor groups
colorset <- brewer.pal(length(f_types), "Set2")
color.map <- function(factor_id) {return(colorset[ which(f_types==BDLfactors$ftype[which(BDLfactors$id==factor_id)]) ])}
factorColors <- unlist(lapply(colnames(BDLdata.fil), color.map))
heatmap.2(t(as.matrix(dtmp)), col=colors(100), scale="row", dendrogram="none", Rowv=NULL, Colv=NULL,
key=TRUE, trace="none", cexRow=0.5, keysize=0.8, density.info="none",
RowSideColors=factorColors,
add.expr=abline(v=v_lines, h=h_lines, col="black", lwd=0.5),
main="Heatmap of BDL time course data")
# xlab="sample", ylab="factor")
legend("left",      # location of the legend on the heatmap plot
inset=c(-0.03,0),
legend = rev(f_types), # category labels
col = rev(colorset),  # color key
lty= 1,             # line style
lwd = 10,            # line width
cex = 0.7,
bty="n"
)
heatmap.2(t(as.matrix(dtmp)), col=colors(100), scale="row", dendrogram="none", Rowv=NULL, Colv=NULL,
key=TRUE, trace="none", cexRow=0.5, keysize=0.8, density.info="none",
RowSideColors=factorColors,
add.expr=abline(v=v_lines, col="black", lwd=0.5),
main="Heatmap of BDL time course data")
# xlab="sample", ylab="factor")
legend("left",      # location of the legend on the heatmap plot
inset=c(-0.03,0),
legend = rev(f_types), # category labels
col = rev(colorset),  # color key
lty= 1,             # line style
lwd = 10,            # line width
cex = 0.7,
bty="n"
)
table(BDLfactors$ftype)
BDLfactors$ftype
rownames(BDLdata.fil)
table(BDLfactors$ftype[rownames(BDLdata.fil)])
BDLfactors[rownames(BDLdata.fil)]
BDLfactors[rownames(BDLdata.fil), ]
rownames(BDLdata.fil)
BDLdata.fil <- BDLdata[, idx.accept]
rownames(BDLdata.fil)
idx.accept = (df.anova$p.holm < p.accept)  # accepted subset
idx.accept
table(idx.accept)
table(BDLfactors$ftype[idx.accept])
table(BDLfactors$ftype)
table(BDLfactors$ftype[idx.accept])
table(BDLfactors$ftype[idx.accept])/table(BDLfactors$ftype)
round(table(BDLfactors$ftype[idx.accept])/table(BDLfactors$ftype), digits = 3)
round(table(BDLfactors$ftype[idx.accept])/table(BDLfactors$ftype), digits = 2)
w
!ls
! ls
system(ls)
system("ls")
system("pdflatex")
