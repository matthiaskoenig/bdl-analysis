}
correlation_matrix_for_method <- function(method){
if (identical(method, "ys1")){
cor.cluster <- cor.ys1
}else if (identical(method, "ys2")){
cor.cluster <- cor.ys2
}else if (identical(method, "ys3")){
cor.cluster <- cor.ys3
}else if (identical(method, "yr1")){
cor.cluster <- cor.yr1
}else if (identical(method, "yr2")){
cor.cluster <- cor.yr2
}else if (identical(method, "yr3")){
cor.cluster <- cor.yr3
}else if (identical(method, "pearson")){
cor.cluster <- cor.pearson
}else if (identical(method, "spearman")){
cor.cluster <- cor.spearman
}
return(cor.cluster)
}
# apply hirarchical clustering based on selected correlation measure
cluster_methods <- c("pearson", "spearman", "ys1", "ys2", "ys3", "yr1", "yr2", "yr3")
Ngroups <-  6
for (method in cluster_methods){
cor.cluster <- correlation_matrix_for_method(method)
# perform hierarchical clustering and cut into Ngroups clusters.
hc <- hclust(dist(cor.cluster))
groups <- cutree(hc, k=Ngroups)
groups.hc.order <- groups[hc$order]
# plot cluster overview
plot_clusters(method=method, folder=NULL)
plot_clusters(method=method, folder=resultsPath)
# plot individual clusters
plot_clusters_items(folder=resultsPath)
}
# Plot the clusters
require('matrixStats')
# mean plots for clusters
f_normalize_centering <- function(a){
a.norm <- (a - mean(a))/(max(a, na.rm=TRUE) - min(a, na.rm=TRUE))
return(a.norm)
}
# plot of mean clusters
plot_clusters <- function(method, folder=NULL){
# create the figure
if (!is.null(folder)){
fname <- sprintf("%s_cluster_overview.png", method)
path <- file.path(folder, 'cluster', fname)
print(path)
png(filename=path, width=1600, height=1600, res=200)
}
par(mfrow=c(ceiling(sqrt(Ngroups)),ceiling(sqrt(Ngroups))))
# par(mfrow=c(2,3))
steps <- 1:8 # time points
for (k in 1:Ngroups){
g <- groups.hc.order[groups.hc.order==k]
N <- ceiling(sqrt(length(g)))
dgroup <- BDLmean[names(g)]
# centralize and normalize columns, i.e. the individual factors for comparison
dgroup.norm <- apply(dgroup, 2, f_normalize_centering)
# mean and sd for timepoints
g.mean <- rowMeans(dgroup.norm)
g.sd <- rowSds(dgroup.norm)   # apply(dgroup.norm, 2, sd)
# plot sd range
plot(1, type="n", xlab="", ylab="", xlim=c(1, 8), ylim=c(-1, 1), main=sprintf("%s : Cluster %s", method, k))
polygon(c(steps, rev(steps)), c(g.mean+g.sd, rev(g.mean-g.sd)),
col = rgb(0.5,0.5,0.5,0.5), border = NA)
# individual data
for (name in names(g)){
points(steps, dgroup.norm[, name], pch=16, col="black")
lines(steps, dgroup.norm[, name], col=rgb(0.5,0.5,0.5, 0.8), lwd=1)
}
# mean over factors in cluster
lines(steps, g.mean, col="blue", lwd=2)
}
par(mfrow=c(1,1))
if (!is.null(folder)){
invisible(dev.off())
}
}
# Plot individual time courses in cluster
plot_clusters_items <- function(folder=NULL){
for (k in 1:Ngroups){
if (!is.null(folder)){
fname <- sprintf("%s_cluster_%s.png", method, k)
path <- file.path(folder, 'cluster', fname)
png(filename=path, width=3000, height=3000, res=200)
}
g <- groups.hc.order[groups.hc.order==k]
N <- ceiling(sqrt(length(g)))
par(mfrow=c(N,N))
for (name in names(g)){
plot_single(name_A=name)
}
par(mfrow=c(1,1))
if (!is.null(folder)){
invisible(dev.off())
}
}
}
correlation_matrix_for_method <- function(method){
if (identical(method, "ys1")){
cor.cluster <- cor.ys1
}else if (identical(method, "ys2")){
cor.cluster <- cor.ys2
}else if (identical(method, "ys3")){
cor.cluster <- cor.ys3
}else if (identical(method, "yr1")){
cor.cluster <- cor.yr1
}else if (identical(method, "yr2")){
cor.cluster <- cor.yr2
}else if (identical(method, "yr3")){
cor.cluster <- cor.yr3
}else if (identical(method, "pearson")){
cor.cluster <- cor.pearson
}else if (identical(method, "spearman")){
cor.cluster <- cor.spearman
}
return(cor.cluster)
}
# apply hirarchical clustering based on selected correlation measure
cluster_methods <- c("pearson", "spearman", "ys1", "ys2", "ys3", "yr1", "yr2", "yr3")
Ngroups <-  6
for (method in cluster_methods){
cor.cluster <- correlation_matrix_for_method(method)
# perform hierarchical clustering and cut into Ngroups clusters.
hc <- hclust(dist(cor.cluster))
groups <- cutree(hc, k=Ngroups)
groups.hc.order <- groups[hc$order]

# plot cluster overview
plot_clusters(method=method, folder=NULL)
plot_clusters(method=method, folder=resultsPath)
# plot individual clusters
plot_clusters_items(folder=resultsPath)
}
# Plot the clusters
require('matrixStats')
# mean plots for clusters
f_normalize_centering <- function(a){
a.norm <- (a - mean(a))/(max(a, na.rm=TRUE) - min(a, na.rm=TRUE))
return(a.norm)
}
# plot of mean clusters
plot_clusters <- function(method, folder=NULL){
# create the figure
if (!is.null(folder)){
fname <- sprintf("%s_cluster_overview.png", method)
path <- file.path(folder, 'cluster', fname)
print(path)
png(filename=path, width=1600, height=1600, res=200)
}
par(mfrow=c(ceiling(sqrt(Ngroups)),ceiling(sqrt(Ngroups))))
# par(mfrow=c(2,3))
steps <- 1:8 # time points
for (k in 1:Ngroups){
g <- groups.hc.order[groups.hc.order==k]
N <- ceiling(sqrt(length(g)))
dgroup <- BDLmean[names(g)]
# centralize and normalize columns, i.e. the individual factors for comparison
dgroup.norm <- apply(dgroup, 2, f_normalize_centering)
# mean and sd for timepoints
g.mean <- rowMeans(dgroup.norm)
g.sd <- rowSds(dgroup.norm)   # apply(dgroup.norm, 2, sd)
# plot sd range
plot(1, type="n", xlab="", ylab="", xlim=c(1, 8), ylim=c(-1, 1), main=sprintf("%s : Cluster %s", method, k))
polygon(c(steps, rev(steps)), c(g.mean+g.sd, rev(g.mean-g.sd)),
col = rgb(0.5,0.5,0.5,0.5), border = NA)
# individual data
for (name in names(g)){
points(steps, dgroup.norm[, name], pch=16, col="black")
lines(steps, dgroup.norm[, name], col=rgb(0.5,0.5,0.5, 0.8), lwd=1)
}
# mean over factors in cluster
lines(steps, g.mean, col="blue", lwd=2)
}
par(mfrow=c(1,1))
if (!is.null(folder)){
invisible(dev.off())
}
}
# Plot individual time courses in cluster
plot_clusters_items <- function(folder=NULL){
for (k in 1:Ngroups){
if (!is.null(folder)){
fname <- sprintf("%s_cluster_%s.png", method, k)
path <- file.path(folder, 'cluster', fname)
png(filename=path, width=3000, height=3000, res=200)
}
g <- groups.hc.order[groups.hc.order==k]
N <- ceiling(sqrt(length(g)))
par(mfrow=c(N,N))
for (name in names(g)){
plot_single(name_A=name)
}
par(mfrow=c(1,1))
if (!is.null(folder)){
invisible(dev.off())
}
}
}
correlation_matrix_for_method <- function(method){
if (identical(method, "ys1")){
cor.cluster <- cor.ys1
}else if (identical(method, "ys2")){
cor.cluster <- cor.ys2
}else if (identical(method, "ys3")){
cor.cluster <- cor.ys3
}else if (identical(method, "yr1")){
cor.cluster <- cor.yr1
}else if (identical(method, "yr2")){
cor.cluster <- cor.yr2
}else if (identical(method, "yr3")){
cor.cluster <- cor.yr3
}else if (identical(method, "pearson")){
cor.cluster <- cor.pearson
}else if (identical(method, "spearman")){
cor.cluster <- cor.spearman
}
return(cor.cluster)
}
# apply hirarchical clustering based on selected correlation measure
cluster_methods <- c("pearson", "spearman", "ys1", "ys2", "ys3", "yr1", "yr2", "yr3")
Ngroups <-  6
for (method in cluster_methods){
cor.cluster <- correlation_matrix_for_method(method)
# perform hierarchical clustering and cut into Ngroups clusters.
hc <- hclust(dist(cor.cluster))
groups <- cutree(hc, k=Ngroups)
groups.hc.order <- groups[hc$order]

# plot cluster overview
plot_clusters(method=method, folder=NULL)
plot_clusters(method=method, folder=resultsPath)
# plot individual clusters
plot_clusters_items(folder=resultsPath)
}
require('matrixStats')
# mean plots for clusters
f_normalize_centering <- function(a){
a.norm <- (a - mean(a))/(max(a, na.rm=TRUE) - min(a, na.rm=TRUE))
return(a.norm)
}
# plot of mean clusters
plot_clusters <- function(method, folder=NULL){
# create the figure
if (!is.null(folder)){
fname <- sprintf("%s_cluster_overview.png", method)
path <- file.path(folder, 'cluster', fname)
print(path)
png(filename=path, width=1600, height=1600, res=200)
}
par(mfrow=c(ceiling(sqrt(Ngroups)),ceiling(sqrt(Ngroups))))
# par(mfrow=c(2,3))
steps <- 1:8 # time points
for (k in 1:Ngroups){
g <- groups.hc.order[groups.hc.order==k]
N <- ceiling(sqrt(length(g)))
dgroup <- BDLmean[names(g)]
# centralize and normalize columns, i.e. the individual factors for comparison
dgroup.norm <- apply(dgroup, 2, f_normalize_centering)
# mean and sd for timepoints
g.mean <- rowMeans(dgroup.norm)
g.sd <- rowSds(dgroup.norm)   # apply(dgroup.norm, 2, sd)
# plot sd range
plot(1, type="n", xlab="", ylab="", xlim=c(1, 8), ylim=c(-1, 1), main=sprintf("%s : Cluster %s", method, k))
polygon(c(steps, rev(steps)), c(g.mean+g.sd, rev(g.mean-g.sd)),
col = rgb(0.5,0.5,0.5,0.5), border = NA)
# individual data
for (name in names(g)){
points(steps, dgroup.norm[, name], pch=16, col="black")
lines(steps, dgroup.norm[, name], col=rgb(0.5,0.5,0.5, 0.8), lwd=1)
}
# mean over factors in cluster
lines(steps, g.mean, col="blue", lwd=2)
}
par(mfrow=c(1,1))
if (!is.null(folder)){
invisible(dev.off())
}
}
plot_clusters_items <- function(folder=NULL){
for (k in 1:Ngroups){
if (!is.null(folder)){
fname <- sprintf("%s_cluster_%s.png", method, k)
path <- file.path(folder, 'cluster', fname)
png(filename=path, width=3000, height=3000, res=200)
}
g <- groups.hc.order[groups.hc.order==k]
N <- ceiling(sqrt(length(g)))
par(mfrow=c(N,N))
for (name in names(g)){
plot_single(name_A=name)
}
par(mfrow=c(1,1))
if (!is.null(folder)){
invisible(dev.off())
}
}
}
correlation_matrix_for_method <- function(method){
if (identical(method, "ys1")){
cor.cluster <- cor.ys1
}else if (identical(method, "ys2")){
cor.cluster <- cor.ys2
}else if (identical(method, "ys3")){
cor.cluster <- cor.ys3
}else if (identical(method, "yr1")){
cor.cluster <- cor.yr1
}else if (identical(method, "yr2")){
cor.cluster <- cor.yr2
}else if (identical(method, "yr3")){
cor.cluster <- cor.yr3
}else if (identical(method, "pearson")){
cor.cluster <- cor.pearson
}else if (identical(method, "spearman")){
cor.cluster <- cor.spearman
}
return(cor.cluster)
}
# apply hirarchical clustering based on selected correlation measure
cluster_methods <- c("pearson", "spearman", "ys1", "ys2", "ys3", "yr1", "yr2", "yr3")
Ngroups <-  6
for (method in cluster_methods){
cor.cluster <- correlation_matrix_for_method(method)
# perform hierarchical clustering and cut into Ngroups clusters.
hc <- hclust(dist(cor.cluster))
groups <- cutree(hc, k=Ngroups)
groups.hc.order <- groups[hc$order]

# plot cluster overview
plot_clusters(method=method, folder=NULL)
plot_clusters(method=method, folder=resultsPath)
# plot individual clusters
plot_clusters_items(folder=resultsPath)
}
for (method in cluster_methods){
cor.cluster <- correlation_matrix_for_method(method)
}
for (method in cluster_methods){
cor.cluster <- correlation_matrix_for_method(method)
}
for (method in cluster_methods){
cor.cluster <- correlation_matrix_for_method(method)
# perform hierarchical clustering and cut into Ngroups clusters.
hc <- hclust(dist(cor.cluster))
groups <- cutree(hc, k=Ngroups)
groups.hc.order <- groups[hc$order]
}
for (method in cluster_methods){
cor.cluster <- correlation_matrix_for_method(method)
# perform hierarchical clustering and cut into Ngroups clusters.
hc <- hclust(dist(cor.cluster))
groups <- cutree(hc, k=Ngroups)
groups.hc.order <- groups[hc$order]

# plot cluster overview
plot_clusters(method=method, folder=NULL)
plot_clusters(method=method, folder=resultsPath)
}
plot_clusters(method=method, folder=NULL)
plot_clusters(method=method, folder=resultsPath)
for (method in cluster_methods){
cor.cluster <- correlation_matrix_for_method(method)
# perform hierarchical clustering and cut into Ngroups clusters.
hc <- hclust(dist(cor.cluster))
groups <- cutree(hc, k=Ngroups)
groups.hc.order <- groups[hc$order]

# plot cluster overview
plot_clusters(method=method, folder=NULL)
plot_clusters(method=method, folder=resultsPath)
}
for (method in cluster_methods){
print(method)
cor.cluster <- correlation_matrix_for_method(method)
# perform hierarchical clustering and cut into Ngroups clusters.
hc <- hclust(dist(cor.cluster))
groups <- cutree(hc, k=Ngroups)
groups.hc.order <- groups[hc$order]

# plot cluster overview
plot_clusters(method=method, folder=NULL)
plot_clusters(method=method, folder=resultsPath)
}
cor.cluster <- correlation_matrix_for_method(method)
groups
hc
hc$order
groups[hc$order]
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
rm(list=ls())
source('~/.active-rstudio-document', echo=TRUE)
# Plot the clusters
require('matrixStats')
# mean plots for clusters
f_normalize_centering <- function(a){
a.norm <- (a - mean(a))/(max(a, na.rm=TRUE) - min(a, na.rm=TRUE))
return(a.norm)
}
plot_clusters <- function(method, folder=NULL){
# create the figure
if (!is.null(folder)){
fname <- sprintf("%s_cluster_overview.png", method)
path <- file.path(folder, 'cluster', fname)
print(path)
png(filename=path, width=1600, height=1600, res=200)
}
par(mfrow=c(ceiling(sqrt(Ngroups)),ceiling(sqrt(Ngroups))))
# par(mfrow=c(2,3))
steps <- 1:8 # time points
for (k in 1:Ngroups){
g <- groups.hc.order[groups.hc.order==k]
N <- ceiling(sqrt(length(g)))
dgroup <- BDLmean[names(g)]
# centralize and normalize columns, i.e. the individual factors for comparison
dgroup.norm <- apply(dgroup, 2, f_normalize_centering)
# mean and sd for timepoints
g.mean <- rowMeans(dgroup.norm)
g.sd <- rowSds(dgroup.norm)   # apply(dgroup.norm, 2, sd)
# plot sd range
plot(1, type="n", xlab="", ylab="", xlim=c(1, 8), ylim=c(-1, 1), main=sprintf("%s : Cluster %s", method, k))
polygon(c(steps, rev(steps)), c(g.mean+g.sd, rev(g.mean-g.sd)),
col = rgb(0.5,0.5,0.5,0.5), border = NA)
# individual data
for (name in names(g)){
points(steps, dgroup.norm[, name], pch=16, col="black")
lines(steps, dgroup.norm[, name], col=rgb(0.5,0.5,0.5, 0.8), lwd=1)
}
# mean over factors in cluster
lines(steps, g.mean, col="blue", lwd=2)
}
par(mfrow=c(1,1))
if (!is.null(folder)){
invisible(dev.off())
}
}
# Plot individual time courses in cluster
plot_clusters_items <- function(folder=NULL){
for (k in 1:Ngroups){
if (!is.null(folder)){
fname <- sprintf("%s_cluster_%s.png", method, k)
path <- file.path(folder, 'cluster', fname)
png(filename=path, width=3000, height=3000, res=200)
}
g <- groups.hc.order[groups.hc.order==k]
N <- ceiling(sqrt(length(g)))
par(mfrow=c(N,N))
for (name in names(g)){
plot_single(name_A=name)
}
par(mfrow=c(1,1))
if (!is.null(folder)){
invisible(dev.off())
}
}
}
correlation_matrix_for_method <- function(method){
if (identical(method, "ys1")){
cor.cluster <- cor.ys1
}else if (identical(method, "ys2")){
cor.cluster <- cor.ys2
}else if (identical(method, "ys3")){
cor.cluster <- cor.ys3
}else if (identical(method, "yr1")){
cor.cluster <- cor.yr1
}else if (identical(method, "yr2")){
cor.cluster <- cor.yr2
}else if (identical(method, "yr3")){
cor.cluster <- cor.yr3
}else if (identical(method, "pearson")){
cor.cluster <- cor.pearson
}else if (identical(method, "spearman")){
cor.cluster <- cor.spearman
}
return(cor.cluster)
}
cluster_methods <- c("pearson", "spearman", "ys1", "ys2", "ys3", "yr1", "yr2", "yr3")
Ngroups <-  6
for (method in cluster_methods){
print(method)
cor.cluster <- correlation_matrix_for_method(method)
# perform hierarchical clustering and cut into Ngroups clusters.
hc <- hclust(dist(cor.cluster))
groups <- cutree(hc, k=Ngroups)
groups.hc.order <- groups[hc$order]

# plot cluster overview
plot_clusters(method=method, folder=NULL)
plot_clusters(method=method, folder=resultsPath)
# plot individual clusters
plot_clusters_items(folder=resultsPath)
}
cor.cluster <- correlation_matrix_for_method(method)
hc <- hclust(dist(cor.cluster))
groups <- cutree(hc, k=Ngroups)
groups.hc.order <- groups[hc$order]
plot_clusters(method=method, folder=NULL)
plot_clusters(method=method, folder=resultsPath)
plot_clusters_items(folder=resultsPath)
}
source('~/.active-rstudio-document', echo=TRUE)
library(BDLanalysis)
rm(list=ls())
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
cor.cluster <- correlation_matrix_for_method(method)
source('~/.active-rstudio-document', echo=TRUE)
