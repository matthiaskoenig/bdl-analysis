<!--
%\VignetteEngine{knitr}
%\VignetteIndexEntry{BDL raw data processing}
-->

# BDL Analysis

This script contains the complete statistical analysis for the publication
Pathobiochemical signatures of cholestatic liver disease in bile duct ligated
mice (BMC Systems Biology).

The goal of this work is to analyze two different collections of archived tweets from the ISMB conferences from 2012 and 2014, and compare and contrast them. The 
```{r path}
baseLoc <- system.file(package="BDLanalysis")
extPath <- file.path(baseLoc, "extdata")
resultsPath <- "/home/mkoenig/git/bdl-analysis/results"
```

## Read BDL data
The BDL data, BDL sample definition and the Fluidigm probe definitions are loaded via
```{r BDLdata, eval=TRUE}
library("calibrate")
library('BDLanalysis')
data(BDLdata)
data(BDLsamples)
data(BDLprobes)
```

Calculation of mean timecourse for factors averaged over the 5 repeats.
```{r BDLmean}
BDLmean <- bdl_mean_data(BDLdata, BDLsamples)
BDLmean.time <- as.numeric(levels(as.factor(BDLsamples$time)))
```

Create overview plots for all individual factors. These are stored in the
resultsPath folder.
```{r factorPlots, eval=FALSE}
# Single factor visualization
plot_single_factor(name=colnames(BDLdata)[2])

# Creates plots of all factors in BDLdata
plot_all_factors(path=resultsPath)
```


## Actb controls
Actb was measured on all Fluidigm chips and serves as quality control of the measurement/correlation analysis. The pairwise correlation between all Actb measurements should result in high correlation values
```{r CheckActB}
# Actb control figure
png(filename=file.path(resultsPath, "Actb_control.png"), width=1600, height=600, res=200)
par(mfrow=c(1,3))
plot_cor_pair("Actb", "Actb.x", single_plots=FALSE)
plot_cor_pair("Actb", "Actb.y", single_plots=FALSE)
plot_cor_pair("Actb.x", "Actb.y", single_plots=FALSE)
par(mfrow=c(1,1))
dev.off()

# calculate the correlations
plot_single("Actb")
plot_single("Actb.x")
plot_single("Actb.y")
plot_cor_pair("Actb", "Actb.x", single_plots=FALSE)
plot_cor_pair("Actb", "Actb.y", single_plots=FALSE)
plot_cor_pair("Actb.x", "Actb.y", single_plots=FALSE)

# calculate Spearman and Pearson correlation coefficients on mean and individual
# data
actb.spearman <- cor(data.frame(Actb=BDLdata$Actb, 
                                Actb.x=BDLdata$Actb.x, 
                                Actb.y=BDLdata$Actb.y), method="spearman")

actb.spearman.mean <- cor(data.frame(Actb=BDLmean$Actb, 
                                     Actb.x=BDLmean$Actb.x, 
                                     Actb.y=BDLmean$Actb.y), method="spearman")

actb.pearson <- cor(data.frame(Actb=BDLdata$Actb, 
                               Actb.x=BDLdata$Actb.x, 
                               Actb.y=BDLdata$Actb.y), method="pearson")

actb.pearson.mean <- cor(data.frame(Actb=BDLmean$Actb, 
                                    Actb.x=BDLmean$Actb.x, 
                                    Actb.y=BDLmean$Actb.y), method="pearson")
print(actb.spearman)
print(actb.spearman.mean)
print(actb.pearson)
print(actb.pearson.mean)
```

Heatmap of the full data set provides an overview over the data quality
```{r heatmap}
library("gplots")
colors <- HeatmapColors() 
heatmap.2(t(as.matrix(BDLdata)), col=colors(100), scale="row", Rowv=NULL, Colv=NULL,
          key=TRUE, trace="none", cexRow=0.5, keysize=0.8)
# TODO: create plot
# TODO: create heatmap function
```

# Dimension reduction via ANOVA
Dimension reduction of the BDL data set is performed by filtering out all factors not changing significantly during the time course. For every single factor an ANOVA is calculated with subsequent filtering based on adjusted p-value (multiple testing correction by testing on all factors). The ANOVA tests if any of the time points has a significantly different mean.


The BDLdata set of all timecourses for the factors is reshaped into matrix form for the ANOVA calculation
```{r BDLmatrix}
BDLmatrices <- bdl_matrix_data(BDLdata, BDLsamples)
print(BDLmatrices[[1]])
```

## Perform ANOVA
Now the ANOVA is calculated for all factors and data.frame of p.values returned
```{r ANOVA}
df.anova <- all_factor_anova()  # calculate ANOVA
df.anova$sig <- sapply(df.anova$p.value, significant_code)  # add significant codes
```


## Adjust p-values for multiple testing
Using the p.adjust function which given a set of p-values, returns p-values adjusted using one of several methods. The Bonferroni, Holm, Hochberg, Hommel are designed to give strong control of the family-wise error rate. There seems no reason to use the unmodified Bonferroni correction because it is dominated by Holm's method, which is also valid under arbitrary assumptions.

The correction is performed using Holm  
(Holm, S. (1979). A simple sequentially rejective multiple test procedure. Scandinavian Journal of Statistics 6, 65-70.)
```{r}
df.anova$p.holm <- p.adjust(df.anova$p.value, method ="holm" , n = length(df.anova$p.value))
df.anova$sig.holm <- sapply(df.anova$p.holm, significant_code) 

# order the results py the adjusted p-values
df.anova.ordered <- df.anova[with(df.anova, order(p.holm)), ]
df.anova.ordered
```
Save the results
``` {r}
write.table(df.anova.ordered, file=file.path(resultsPath, 'BDLanova.csv'), sep="\t", quote=FALSE)
BDLanova <- df.anova
save(df.anova, file=file.path(resultsPath, "BDLanova.Rdata"))
```

Filter the data set based on the significance in the ANOVA.


Display the filtered data sets


